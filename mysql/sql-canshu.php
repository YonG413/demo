#### SQL参数化查询为什么能够防止SQL注入

SQL参数化查询是一种防止SQL注入攻击的有效方法，它之所以能够提供安全性，是因为它明确将用户提供的输入值与SQL查询的结构分离开来。以下是SQL参数化查询如何工作以及为何能够防止SQL注入的原因：

参数化输入值：在SQL参数化查询中，不像直接将用户输入值插入到SQL查询字符串中，而是将用户输入值视为参数，然后将这些参数绑定到查询中。参数通常以占位符的形式出现，具体的值在执行查询时提供。

SQL查询模板：SQL参数化查询使用一个SQL查询模板，该模板中包含了占位符，表示需要在运行时替换的参数值。这个查询模板是静态的，不会随用户输入的变化而改变。

绑定参数值：用户输入值被安全地绑定到查询的占位符上，这是在应用程序代码层面完成的。绑定参数值的过程会对用户输入进行验证和转义，确保输入不会被误解为SQL代码的一部分。

防止SQL注入：因为参数值与查询结构分开，并且在绑定时经过了验证和转义，所以即使用户提供了恶意输入，也不会影响SQL查询的结构。这样，攻击者无法通过输入恶意数据来破坏原始的SQL查询，从而防止了SQL注入攻击。



以下是一个详细的例子，说明为什么参数化查询能够防止SQL注入：

**不使用参数化查询的情况：**

假设你有一个网站，用户可以通过用户名和密码登录。你的登录查询可能如下所示（假设使用PHP）：

```php
$username = $_POST['username'];
$password = $_POST['password'];

$query = "SELECT * FROM users WHERE username='$username' AND password='$password'";
```

这个查询将用户提供的`username`和`password`变量直接嵌入到SQL查询字符串中。如果攻击者在`username`或`password`字段中输入恶意的SQL代码，比如：

```sql
' OR '1'='1
```

则构成的查询将变成：

```sql
SELECT * FROM users WHERE username='' OR '1'='1' AND password=''
```

这个查询将始终返回所有用户的数据，因为`'1'='1'`是一个始终为真的条件，这就是SQL注入攻击成功的例子。

**使用参数化查询的情况：**

现在，让我们使用参数化查询来改进登录查询：

```php
$username = $_POST['username'];
$password = $_POST['password'];

$query = "SELECT * FROM users WHERE username=? AND password=?";
$stmt = $pdo->prepare($query);
$stmt->execute([$username, $password]);
```

在这里，我们使用了`?`占位符来代替实际的用户输入，并使用数据库连接的`prepare`方法来准备查询。然后，我们使用`execute`方法来执行查询，并将实际的用户输入传递给`execute`方法。

此时，如果攻击者尝试输入恶意的SQL代码，例如：

```sql
' OR '1'='1
```

不会产生预期的攻击效果，因为这个输入将被视为普通字符串，而不是SQL代码的一部分。最终构成的查询仍然是：

```sql
SELECT * FROM users WHERE username=''' OR '1'='1' AND password='password'
```

这个查询不会返回所有用户的数据，因为`'1'='1'`不会生效，密码部分也不匹配。这就是参数化查询如何防止SQL注入的例子。

总结来说，使用参数化查询，用户输入被视为数据而不是代码，因此无论用户输入什么，都不会改变查询的结构，从而有效地防止了SQL注入攻击。因此，建议始终使用参数化查询来处理用户提供的数据以提高应用程序的安全性。